[toc]

## 常见索引失效

### 查询条件包含or

查询条件包含or时，不管or中涉及到的列是否包含索引，其都会失效。

* 如果 `OR` 的两边条件中，只有部分条件能使用索引，MySQL 通常会放弃使用索引，改为全表扫描。因为 `OR` 条件下需要综合所有部分结果。
* `OR` 的条件涉及多个字段，而这些字段都有单独的索引，MySQL **可能会部分利用索引**，但具体行为依赖查询优化器的决策和数据分布情况，通常，我们无法控制这种行为，所以因该认为使用or时，索引失效

`解决办法`

​	使用UNION或UNION ALL

### 查询条件包含隐式转换

当某列查询发生隐式转换时(如age为数值类型，但是条件为 age="18")

* 当发生隐式转换时，mysql会把列对应的数据转换成传入类型和条件传入数据进行比较，所以他将不使用索引，而是全表扫描。
  * 目前没有办法设置mysql把传入的数据类型转换成条件列对应类型。

`解决办法`

​	手动强制传入相同数据类型。

### like通配符失效

像 '%ABC'这种like匹配会导致索引失效，但是'ABC%'这种不会。

* %在左边导致最左法则被破坏，因为B+Tree索引的结构支持从左向右匹配索引值。

`解决方法`

​	不使用like或尽量保证%在右边

### 联合索引失效

使用联合索引时，不遵循最左连续原则。

* B+Tree的联合索引存储方式决定的

`解决办法`

​	尽量使用最左原则。

### 对索引列的运算

任何对索引列字段的操作也会导致索引失效，这些操作包括以下

#### +、-、*、/

`例子`

```sql
SELECT * FROM users WHERE age + 1 = 30;
```

* 索引存储的是原始的索引列的值，而不是计算后的值。所以对索引列进行上述操作后，会导致索引失效。

#### !=、>、<

例子

```
SELECT * FROM users WHERE age != 30;
```

- 不等号查询会匹配表中所有不等于某值的记录，这个范围通常不连续，所以无法用到索引。
- B+Tree 索引擅长处理连续范围（如 `>` 或 `<`），但是这些条件在有些情况下，mysql优化器会觉得全表扫描更快。

#### Not in、is null、is not null、in

同!=，可能发生数据量较大且散布不均，MySQL 优化器可能会选择全表扫描而不是索引查找。

#### 对索引列的函数调用

索引存储的是原始的索引列的值，而不是计算后的值。所以对索引列进行函数操作后，不再是原先的索引，会导致索引失效。

#### join各个表的编码类型不同

相当于隐式转换。通常是字符串类型的匹配会发生索引失效。

* 例如表 A 的a列使用 utf8mb4  表 B 的b列使用 latin1，当join on A.a==B.b 时，会把A.a转换成latin1类型去匹配B.b。而索引是utf8mb4类型。

### mysql优化器认为全表扫描和索引效率差不多或更快

