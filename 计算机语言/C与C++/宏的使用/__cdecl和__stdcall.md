## \__cdecl和__stdcall

1、\_\_cdecl和\_\_stdcall都是参数从右到左入栈。

2、\_\_cdecl是调用者负责清理栈中的参数，如A函数中调用B函数，参数由A函数负责清理；\_\_stdcall是被调用者负责清理栈中的参数，如A函数中调用B函数，参数由B函数负责清理。

3、\_\_cdecl调用方式不需要知道参数的个数，若要实现变参函数，则要使用这种调用方式，这种成为手动清理（因为调用函数需要生成清理代码）。而\_\_stdcall因为参数栈空间由被调用者清理，则必须知道参数的个数(栈空间大小)，这种方式为自动清理（因为由被调函数清理，调用函数无需成清理）。

4、\_\_stdcall 对比 \_\_cdecl调用方式 ，\_\_cdecl是调用者恢复堆栈的，假设有一百个不同的函数调用函数B，那么内存中就有一百段恢复堆栈的代码，\_\_stdcall是被调用者恢复堆栈，只有在函数代码的结尾出现一次恢复堆栈的代码，所以节约空间。

5、恢复堆栈的代码是编译器根据你给它的调用方式自动生成的，所以无需考虑，而告诉编译器调用方式的意义就在这里。如果一方用\_\_cdecl，而一方用\_\_stdcall(声明和定义不同)，可能出现没有人释放堆栈的情况，这明显是不允许的。

* **Linux** 上，默认的调用约定是 **`__cdecl`**，**`__stdcall`** 不是 Linux 上的标准调用约定，通常你不会在 Linux 上使用它。GCC 不支持 `__stdcall`，它通常用于 Windows 平台的 WinAPI 或一些特定的调用约定。
* **Windows** 上，**`__cdecl`** 是默认的调用约定，而 **`__stdcall`** 需要显式声明，通常用于 WinAPI 函数。

* 定义的约定和使用的约定不一致，则将导致堆栈被破坏，导致严重问题。

* `__cdecl` 和 `__stdcall` 互相调用并不会导致问题出现，他们只是当前函数对参数的清理约定。