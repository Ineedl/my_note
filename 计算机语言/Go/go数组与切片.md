## 切片和数组的区别

切片可以进行扩容和添加,但是数组不可以,数组等同于容量确定且容量不可变的切片

* 当切片和数组作为参数在函数（func）中传递时，数组传递的是值，而切片传递的是指针。因此当传入的切片在函数中被改变时，函数外的切片也会同时改变。相同的情况，函数外的数组则不会发生任何变化。

## 切片底层

当切片传入函数时，函数和切片使用的底层数组是同一个(引用不同)，但如果函数中切片进行了append，导致切片扩容，则将会替换底层数组。

```go
func main() {
	l := make([]int, 0, 1) //容量1
	l = append(l, 3)
	fmt.Println(&l[0])
	tmp(l)
}

func tmp(l []int) {
	fmt.Println(&l[0])
	l = append(l, 1) //出现扩容
	fmt.Println(&l[0])
}

//上述代码打印结果 前两个地址一致，第三个和前两个不一致

//-------------------------------------------------------------------------------

func main() {
	l := make([]int, 0, 2) //容量1
	l = append(l, 3)
	fmt.Println(&l[0])
	tmp(l)
    fmt.Println(l[1]) //发生异常,main中的切片1中未记录自己长度为2 实际底层数组已经有两个长度了
}

func tmp(l []int) {
	fmt.Println(&l[0])
	l = append(l, 1) //未现扩容
	fmt.Println(&l[0])
}

//上述代码打印结果 前三个地址一致

```







## 创建数组

```go
//创建容量为3的数组,当[ ]内为...时,容量由数组后面的值个数决定
num := [...]int{1,2,3}

//创建三个空值的数组
num := [3]int{}
```

* 数组无法使用make创建,并且无法使用append添加内容

## 创建切片

```go
//创建一个初始有2个数值(全为0),扩容前长度最长为4的切片
//可以不指定第二个和第三个参数
//不指定第三个参数时,容量等于第二个参数
//不指定第二个和第三个参数时,创建的一个空切片
tmp := make([]int,2,4)

//创建一个从1到10内容的切片
tmp2 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}


var numbers = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
//获取numbers里面的前三个值,并做成一个容量为3的切片
myslice := numbers[0:1:3]
```

* 从数组或者切片切取切片时,是直接生成,而不是对原有的切片/数组进行某个位置的引用

## 切片的扩容

最初获得的切片,在切片的长度达到容量后,会对切片进行容量乘2倍的扩容

```go
var tmp = make([]int,2,3)
fmt.Printf("tmp为 %d, 其容量为: %d\n", tmp, cap(tmp))
//tmp为 [0 0], 其容量为: 3
tmp = append(tmp,1,1)
fmt.Printf("tmp为 %d, 其容量为: %d\n", tmp, cap(tmp))
//tmp为 [0 0 1 1], 其容量为: 6
```

## 切片常用函数

#### cap

获取当前切片的容量

#### len

获取切片的长度

#### append

往切片中添加内容