## std::future

std::future提供了一种访问异步操作结果的机制。在进行异步操作时，可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。

* std::future不会单独的被拿来创建对象使用，而是和下面的几个一起使用

#### future的三种状态

std::future的状态类型为std::future_status，他们由future的wait_for返回，分别为：

- deferred：异步操作还没开始
- ready：异步操作已经完成
- timeout：异步操作超时

#### 操作结果的获取

获取future结果有三种方式：get、wait、wait_for，其中get等待异步操作结束并返回结果，wait只是等待异步操作完成，没有返回值，wait_for是超时等待返回结果。



## std::promise

std::promise为获取线程函数中的某个值提供便利，在线程函数中给外面传进来的promise赋值，当线程函数执行完成之后就可以通过promis获取该值了，值得注意的是取值是间接的通过promise内部提供的future来获取的。

```c++
std::promise<int> pr;
std::thread t([](std::promise<int>& p){p.set_value_at_thread_exit(9);},std::ref(pr));
std::future<int> f = pr.get_future();
auto r = f.get();
```



## std::packaged_task

std::packaged_task它包装了一个可调用的目标（如function, lambda expression, bind expression, or another function object）,以便异步调用，它和promise在某种程度上有点像，promise保存了一个共享状态的值，而packaged_task保存的是一个函数。

```c++
std::packaged_task<int()> task([](){ return 7; });
std::thread t1(std::ref(task)); 
std::future<int> f1 = task.get_future(); 
auto r1 = f1.get();
```



## std::async

std::async等同于一次结合了使用了std::future、std::promise和std::packaged_task。std::async先将异步操作用std::packaged_task包装起来，然后将异步操作的结果放到std::promise中，外面再通过future.get/wait来获取这个未来的结果.

async第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程：

- std::launch::async：在调用async就开始创建线程。
- std::launch::deferred：延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。

```c++
std::future<int> future = std::async(std::launch::async, [](){ 
        std::this_thread::sleep_for(std::chrono::seconds(3));
        return 8;  
    }); 
 
 std::cout << "waiting...\n";
 std::future_status status;
 do {
 status = future.wait_for(std::chrono::seconds(1));
     if (status == std::future_status::deferred) {
     	std::cout << "deferred\n";
     } else if (status == std::future_status::timeout) {
     	std::cout << "timeout\n";
     } else if (status == std::future_status::ready) {
     	std::cout << "ready!\n";
     }
 } while (status != std::future_status::ready); 

std::cout << "result is " << future.get() << '\n';
```

