# C++11常用std结构

[TOC]

## std::result_of

`std::result_of` 是一个 C++ 标准库类型特征（type trait），用于推导函数调用表达式的返回类型。它接受一个函数类型和其对应的参数类型，并返回该函数类型被这些参数调用时的返回类型。

例如，如果有一个函数 `foo`，它接受一个 `int` 类型的参数并返回一个 `double` 类型的值，可以使用 `std::result_of<decltype(foo)(int)>::type` 获取 `foo` 被调用时的返回类型，即 `double`。

在模板元编程中，`std::result_of` 通常用于推导模板函数或函数对象的返回类型，从而使模板参数能够自动推导函数调用的返回类型，避免手动指定返回类型。

* `std::result_of` 可以推导模板函数的返回值。
* `std::result_of<Func(Args...)>::type` 获取到的是一个类型，而不是一个具体的值，其只能被 `decltype`、`sizeof` 等关键字使用。

`使用实例`

```c++
template <class Func, class... Args>
auto AsyncTaskHandler::add_task(Func &&func, Args &&... args) -> std::future<typename std::result_of<Func(Args...)>::type>
    
    
//此处std::result_of<Func(Args...)>::type被当作类型了
using return_type = typename std::result_of<Func(Args...)>::type;
```

## std::forward

`std::forward` 是一个 C++11 中引入的模板函数，主要用于在模板函数中将参数完美转发到其他函数中。它的作用类似于 `std::move`，不同的是 `std::forward` 可以根据参数类型选择性地进行左值引用或右值引用，以保留参数的值类别。

`例子`

```
template <typename T>
void process(T&& arg) {
    // 处理 arg
    // ...
    other_function(std::forward<T>(arg));
}
```

`process` 函数的 `T&&`这个引用可以接受任意类型的参数，并根据参数的值类别自动选择左值引用或右值引用。在调用 `other_function` 时，使用了 `std::forward<T>(arg)`，它会将 `arg` 以完美转发的方式传递给 `other_function`。

如果 `arg` 是一个左值，即一个具名对象，那么 `std::forward<T>(arg)` 将会返回一个左值引用。如果 `arg` 是一个右值，即一个临时对象或 `std::move` 后的对象，那么 `std::forward<T>(arg)` 将会返回一个右值引用。这样，`other_function` 就可以正确地处理 `arg` 的值类别，避免不必要的拷贝或移动操作，提高代码效率。

需要注意的是，`std::forward` 只能用于模板函数中的参数，而不能用于普通函数中的参数。因为普通函数中的参数已经有了确定的类型，无法根据值类别选择左值引用或右值引用。

## std::make_shared

`std::make_shared` 是一个 C++11 中引入的模板函数，用于创建一个指向动态分配的对象的 `std::shared_ptr` 智能指针。它的可以：

- 简化动态分配和智能指针的使用：可以通过 `std::make_shared` 一次性完成对象的动态分配和智能指针的创建。
- 提高性能：`std::make_shared` 可以避免动态分配内存和引用计数分别分配两次的开销，从而提高性能和减少内存占用。

## std::bind

`std::bind` 是一个 C++11 中引入的函数模板，用于将一个可调用对象（函数、函数指针、成员函数、函数对象等）和其参数绑定成一个新的可调用对象。

`std::bind` 的作用在于：

- 延迟调用：将一个可调用对象和一部分参数绑定后，可以延迟到后续的某个时间点再进行调用，从而实现延迟调用的效果。
- 部分应用：将一个可调用对象的一部分参数绑定后，得到一个新的可调用对象，可以将这个新的可调用对象传递给其他函数或对象，从而实现部分应用的效果。

`实例`

```c++

using return_type = typename std::result_of<Func(Args...)>::type;

auto task = std::make_shared<std::packaged_task<return_type()> >(std::bind(std::forward<Func>(func), std::forward<Args>(args)...));
```

