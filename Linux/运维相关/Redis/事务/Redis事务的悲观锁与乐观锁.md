## Redis中事务的问题
Redis中多个事务同时使用时，仍然是使用单线程处理数据，但在事务开启后，在事务中看到的都是原始数据的假象，在最后事务执行时，才会对对应的数据使用事务中的操作进行修改，哪怕原始数据经过其他事务的修改已经不是当前事务满意的初始状态。




## Redis中的悲观锁
悲观锁锁住一个数据，当该数据被某一个事务占用时，在该事务处理完数据前，其他要使用该事务将会被阻塞。

Redis中的悲观锁Redis自身并不提供，需要使用者用代码来逻辑上的实现


## Redis中的乐观锁
Redis中提供乐观锁而且乐观锁使用watch命令来实现。

> Redis中的乐观锁的实现原理

1. Redis中当用watch命令监视一个数据的时候，会给该数据分配一个随机的版本号。  

2. 事务拿到这被监视数据的拷贝时，也会拿到该数据的版本号，而且事务在最后修改该数据的执行阶段会检查数据的版本号和之前获取该数据的拷贝时是否一致，如果是一致就可以修改。

3. 如果某个事务修改了该数据，也会对应修改该数据的版本号为某一个新的版本号。当其他事务尝试修改该数据时如果该数据版本与原先提取的该数据的拷贝不一致，则打断事务。

* 注意对应事务拷贝的数据版本号在该事务中不会变，哪怕外部已有事务执行了unwatch,exec或者DISCARD取消了对该变量的监视。而且哪怕外面取消了监视，事务内部不取消仍然会监视该变量。