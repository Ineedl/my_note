[toc]

## 变化

C++17 对继承构造函数（inheriting constructors）并没有做非常大的语法层面变动，但在使用和语义上有一些更明确的规范和修正，避免了之前版本中的一些潜在问题和不一致。

### C++17 对继承构造函数的主要变化和规范

### 1. 派生类隐式生成的继承构造函数行为更明确

**背景问题：**
 C++11/14 继承构造函数时，派生类隐式生成的默认构造函数、拷贝构造函数、移动构造函数与继承构造函数的交互逻辑不够清晰，导致一些编译器表现不一，容易产生二义性或未定义行为。

**C++17改进点：**

- 标准明确规定：
  - 派生类如果没有显式声明默认构造函数，且基类有继承构造函数，则编译器会生成隐式默认构造函数（前提是基类默认构造函数可用）。
  - 派生类的拷贝/移动构造函数生成规则也更清晰，继承构造函数不会阻止它们隐式生成。
- 这样避免了派生类因“using Base::Base”导致默认构造函数等隐式构造函数丢失的情况。

**实际意义：**
 你可以放心用继承构造函数，不用担心它会阻塞默认或拷贝/移动构造函数的隐式生成，减少写构造函数的痛苦。

------

### 2. 继承构造函数与虚继承兼容性增强

**背景问题：**
 虚继承（`virtual`继承）在基类构造函数调用顺序和对象布局上更复杂。早期标准对继承构造函数在虚继承场景的行为描述不够细致，导致有些编译器实现存在差异，且有时派生类使用继承构造函数时无法正确初始化虚基类子对象。

**C++17改进点：**

- 规范中对派生类继承构造函数在虚继承场景下的调用路径和初始化顺序做了补充，明确了虚基类的构造调用必须由最终派生类负责。
- 继承构造函数不会绕过虚基类构造的规则，编译器必须保证虚基类正确初始化。

**实际意义：**
 虽然标准更严谨，但仍要注意虚继承场景下继承构造函数的使用，有时手写显式构造函数更保险，避免隐式调用带来难排查的初始化问题。

------

### 3. 修正了继承构造函数的 `explicit` 传播规则

**背景问题：**
 继承构造函数是否保留基类构造函数的 `explicit` 修饰在C++11/14存在不一致：有些实现去掉了`explicit`，导致隐式转换意外生效，或反之。

**C++17改进点：**

- 标准明确规定，继承构造函数严格保留基类对应构造函数的 `explicit` 修饰。
- 换言之，如果基类构造函数是 `explicit`，继承构造函数也是 `explicit`，不会自动“松绑”。

**实际意义：**
 你必须根据基类构造函数的 `explicit` 修饰来预期派生类继承构造函数的行为，防止隐式转换漏洞或意外错误。

------

### 4. 消除重复定义问题

**背景问题：**
 早期版本中，`using Base::Base` 如果遇到派生类中已经定义了相同签名的构造函数，会导致编译器报重复定义错误。

**C++17改进点：**

- 标准规定派生类如果已经显式定义了对应签名的构造函数，则继承构造函数不再生成对应的构造函数，避免重复定义。
- 这让继承构造函数的使用更安全，避免“你写了一个构造函数，继承构造函数又来重定义”这种尴尬。

**实际意义：**
 你可以在派生类里自定义部分构造函数，同时继承基类其他构造函数，不用担心冲突，代码写起来更灵活。

------

### 5. 继承构造函数和模板构造函数共存问题

**背景问题：**
 模板构造函数（比如`template<typename T> Derived(T&&);`）与继承构造函数签名可能冲突或重叠，导致编译器解析时产生歧义。

**C++17改进点：**

- 标准更详细地规定了解析优先级：
  - 非模板继承构造函数优先匹配非模板调用。
  - 如果没有匹配的非模板继承构造函数，才考虑模板构造函数。
- 这样避免模板构造函数“抢了”继承构造函数的调用，减少二义性和编译错误。

**实际意义：**
 在存在模板构造函数时，继承构造函数依然能正常工作，匹配优先级更合理，不用担心模板构造函数覆盖导致继承构造函数失效。